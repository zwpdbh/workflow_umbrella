# ACStor Playground

## Introduction

This livebook is used to play as REPL for developing ACStor Scenario.
So, start workflow_umbrella project and connect to it as attached node.

```elixir
# Test to see if we could get auth token from workflow_umbrella project.
alias Azure.Auth
Auth.get_auth_token(Auth.azure_scope())
```

<!-- livebook:{"branch_parent_index":0} -->

## Test log to a local file

```elixir
alias Steps.Exec
```

```elixir
Steps.Common.Time.get_time_millisecond()
```

```elixir
log_file = Steps.LogBackend.create_tmp_log_file("playground.txt")
```

```elixir
Exec.run(%{cmd: "ls -la", log_file: log_file})
```

```elixir
Exec.run(%{cmd: "ls filenotexist", log_file: log_file})
```

<!-- livebook:{"branch_parent_index":0} -->

## Test replication steps and log to a file

```elixir
alias Steps.Acstor.Replication, as: Rep
```

```elixir
log_file = Steps.LogBackend.create_tmp_log_file("replication.txt")
```

```elixir
settings = %{
  sub: "65490f91-f2c2-4514-80ba-4ec1de89aeda",
  region: "eastus",
  rg: "acstor-replication-test",
  session_dir: "/tmp/logs/2023-8-26/az_cli_sessions/lot2mn"
}
```

```elixir
settings |> Rep.az_set_subscription()
```

<!-- livebook:{"branch_parent_index":0} -->

## How to use Worker to execute ACStor replication

* For one scenario such as managed disk, `Worker.Leader` load different settings from a scenario setting service. Such as number of disks, run time. 
  The purpose of this is to generate different settings for each workflow later to use.

* `Worker.Leader` specify how many `Worker` are created. There could be `M` workers for `N` workflows.

* For replication, when `Worker.Leader` assign workflow to `worker`, it need to reset worker's some interal state (such as: AKS cluster name)

* A `Worker` use inital settings got from `Worker.Leader` to run workflow by execute each steps in the workflow.

* After each step is execute by a `Worker`, the state of the `Worker` need to be updated by that step.

Each step is a pure function from Steps.Acstor.Replication module.

* We update a `Worker`'s state by wrapping the pure function in another function.

**Update**

* `Worker` no longer execute workflows, it doesn't know about workflows.
* `Worker` only care about executing a step.
* The concept of workflow which is the sequence of steps is kept only in `Worker.Leader`.

## Scenario Settings

```elixir
symbol = "azure_disk_replication"
```

<!-- livebook:{"branch_parent_index":4} -->

## Test 01: start scenario

```elixir
# Start a scenario
Workflow.start_scenario(symbol)
```

```elixir
Kino.Process.render_sup_tree(DynamicSymbolSupervisor)
```

```elixir
# Stop a scenario
Workflow.stop_scenario(symbol)
```

<!-- livebook:{"branch_parent_index":4} -->

## Test 02: execute one step from worker

```elixir
{:ok, worker_pid} = Worker.Leader.get_worker_by_name(symbol, "worker1")
```

```elixir
Worker.run_step(%{
  worker_pid: worker_pid,
  module_name: "Steps.Acstor.Replication",
  step_name: "az_login_using_sp"
})
```

```elixir
Worker.run_step(%{
  worker_pid: worker_pid,
  module_name: "Steps.Acstor.Replication",
  step_name: "az_set_subscription"
})
```

```elixir
# check worker context
Worker.current_state(worker_pid)
```
