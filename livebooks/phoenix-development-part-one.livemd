# Full-stack development in phoenix -- Part one

## Introduction

As we could execute multiple scenarios(symbols) with multiple workflows for each one (POC finished). It is neccessary to implement the frontend part to better track and display their results.

The goal of frontend is:

* Start/Stop scenarios(symbols)
* Add/remove workers from symbol.
* User submit workflow definition.
* Run multiple workfows from workflow definition.
* Track workflows status.
* Track steps status.

## Define schema for our data

Currently, the data model is simply defined as struct and their relationship is not well defined.
I need to use `Ecto.Schema` to formally structure them.

In general, there are two parts:

* The static part for different definitions, such as workflow definition.
* The runtime part for different instances, such as a workflow instance.

Questions to review

* How about other parts, like the hierarchy of the system? Do I need to store it? 
  * That graph should be embeded into the model relationship.
  * It means without actually running the system, we could simulate the system by manipulating the data from our model.
* We could define those most obvious model, and extent the models gradually.
  * In this case, `WorkflowInstance` is the center.

<!-- livebook:{"break_markdown":true} -->

### Steps for init DB

Run `docker-compose up -d`, and cd into `workflow_umbrella/apps/workflow` folder:

* Create init script: `mix ecto.gen.migration init`
* Edit the generated `xxx.exs` file.
* Run `mix ecto.migrate` to do the table migration.

<!-- livebook:{"break_markdown":true} -->

### Clean up DB

Inside `workflow_umbrella/apps/workflow` folder:

* Option 1: `mix ecto.rollback`
* Option 2: 
  * `mix ecto.drop`
  * `mix ecto.create`

## Simulate the flow of data by unit tests

At this stage, we igore the actuall running of our system. But focus on building the manipulation of data and its model correctness. In other words, use unit test to simulate the result of different operation to test if we could get expected result from it.

<!-- livebook:{"break_markdown":true} -->

### Unit test to cover

Given a workflow definition, we do the following tests

* Save workflow definition.
* Create a workflow instance and save it.
* After saving some data into DB successfully, we use it.

<!-- livebook:{"break_markdown":true} -->

### Play with [Ecto](https://hexdocs.pm/ecto/Ecto.html#content)

```elixir
Workflow.Step.new(%{
  status: :todo,
  module: "some_module",
  function: "some_function",
  index: 2
})
```

```elixir
WorkflowContext.StepContext.create_step(%{
  status: :todo,
  module: "some_module",
  function: "some_function"
})
```

## Features for manage clusters

* [ ] A table show all living clusters (like a index page)
* [ ] start a cluster (in the cluster's detail page)
* [ ] stop a cluster (in the cluster's detail page)

<!-- livebook:{"break_markdown":true} -->

### Setup LiveView page for cluster

<!-- livebook:{"break_markdown":true} -->

Edit `apps/workflow_web/lib/workflow_web/router.ex`

<!-- livebook:{"force_markdown":true} -->

```elixir
# add an extra scope for all live
scope "/live", WorkflowWeb do
  pipe_through(:browser)
  live("/clusters", ClusterLive, :index)
end
```

<!-- livebook:{"break_markdown":true} -->

Create

* apps/workflow_web/lib/workflow_web/live/cluster_live.ex
* apps/workflow_web/lib/workflow_web/live/cluster_live.html.heex

<!-- livebook:{"break_markdown":true} -->

Inside `cluster_live.ex` define the functions

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule WorkflowWeb.Live.ClusterLive do
  use WorkflowWeb, :live_view

  defmodule Index do
    use WorkflowWeb, :live_component
    def mount(_params, _session, socket) do
      # socket = assign(socket, key: value)
      {:ok, socket}
    end
  end
end
```

<!-- livebook:{"break_markdown":true} -->

### Troubleshootings

<!-- livebook:{"break_markdown":true} -->

#### Problem01: UndefinedFunctionError at GET /live/clusters

```
function WorkflowWeb.ClusterLive.Index.init/1 is undefined or private
```

<!-- livebook:{"break_markdown":true} -->

Solution:

* Where is this `init/` come from? This error happend because I use `get` instead of `live` in the router.
* After changing to `live("/clusters", ClusterLive, :index)`, the problem got solved.

## Others -- Phoenix

### [Phoenix.LiveView](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html)

<!-- livebook:{"break_markdown":true} -->

### [Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#content)

* It defines reusable function component with HEEX templates.
* What is `function component` ? 
  It is any function that receives an assigns map as an argument and returns a rendered struct built with `~H` sigil.

<!-- livebook:{"break_markdown":true} -->

### [Phoenix.LiveComponent](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html)

* It is used in a parent LiveView.
* It hass its own state and [life-cycle](https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html#module-summary).
* It is "stateful component" comparing with `Phoenix.Component` is stateless component.

<!-- livebook:{"break_markdown":true} -->

###

## Others -- Ecto

### General steps to setup ecto

see: [Setup ecto inside naive app](https://github.com/zwpdbh/hedgehog/blob/dev/from-ms/documents/playground.livemd#setup-ecto-inside-naive-app)

In general

1. Defines the DB and how to talk to it in Elixir application.
   * Prepare dependencies
   * Add ecto repo to application
   * Config ecto repo in application
   * Setup supervision tree for DB connection.
2. Create database.
3. Create the table by migration 
   * Define migration
   * Run migration
4. Create schema to the table to use data from database table.

<!-- livebook:{"break_markdown":true} -->

### [Embedded Schemas](https://hexdocs.pm/ecto/embedded-schemas.html)
